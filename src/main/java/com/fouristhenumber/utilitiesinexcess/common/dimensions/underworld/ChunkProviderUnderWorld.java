package com.fouristhenumber.utilitiesinexcess.common.dimensions.underworld;

import static net.minecraftforge.event.terraingen.PopulateChunkEvent.Populate.EventType.ANIMALS;
import static net.minecraftforge.event.terraingen.PopulateChunkEvent.Populate.EventType.LAKE;
import static net.minecraftforge.event.terraingen.PopulateChunkEvent.Populate.EventType.LAVA;

import java.util.Arrays;
import java.util.List;
import java.util.Random;

import net.minecraft.block.Block;
import net.minecraft.entity.EnumCreatureType;
import net.minecraft.init.Blocks;
import net.minecraft.util.IProgressUpdate;
import net.minecraft.util.MathHelper;
import net.minecraft.world.ChunkPosition;
import net.minecraft.world.SpawnerAnimals;
import net.minecraft.world.World;
import net.minecraft.world.biome.BiomeGenBase;
import net.minecraft.world.biome.BiomeGenBase.SpawnListEntry;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.chunk.IChunkProvider;
import net.minecraft.world.gen.feature.WorldGenBigMushroom;
import net.minecraft.world.gen.feature.WorldGenLakes;
import net.minecraft.world.gen.structure.MapGenMineshaft;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.common.util.ForgeDirection;
import net.minecraftforge.event.terraingen.PopulateChunkEvent.Post;
import net.minecraftforge.event.terraingen.PopulateChunkEvent.Pre;
import net.minecraftforge.event.terraingen.TerrainGen;

import com.fouristhenumber.utilitiesinexcess.common.worldgen.util.Box;
import com.fouristhenumber.utilitiesinexcess.common.worldgen.util.ChunkBlockView;
import com.fouristhenumber.utilitiesinexcess.config.dimensions.UnderWorldConfig;
import com.fouristhenumber.utilitiesinexcess.utils.IntRange;
import com.fouristhenumber.utilitiesinexcess.utils.noise.NoiseSampler;
import com.fouristhenumber.utilitiesinexcess.utils.noise.OctavesSampler;
import com.fouristhenumber.utilitiesinexcess.utils.noise.ScaledNoise;
import com.fouristhenumber.utilitiesinexcess.utils.noise.SimplexNoiseSampler;
import com.gtnewhorizon.gtnhlib.hash.Fnv1a64;
import com.gtnewhorizon.gtnhlib.util.CoordinatePacker;
import com.gtnewhorizon.gtnhlib.util.data.BlockMeta;
import com.gtnewhorizon.gtnhlib.util.data.ImmutableBlockMeta;
import it.unimi.dsi.fastutil.longs.LongArrayFIFOQueue;

public class ChunkProviderUnderWorld implements IChunkProvider {

    public static final IntRange FLOOR = new IntRange(50, 70), CEILING = new IntRange(110, 130);

    private static final WorldGenLakes WATER_LAKES = new WorldGenLakes(Blocks.water);
    private static final WorldGenLakes LAVA_LAKES = new WorldGenLakes(Blocks.lava);

    private final World world;
    private final long seed;
    private final Random rng = new Random(0);

    private final NoiseSampler floor, ceiling, feature, difficulty, mushrooms, boulders;

    private final MapGenMineshaft mineshaftGenerator = new MapGenMineshaft();
    private final WorldGenBigMushroom bigMushroomGen = new WorldGenBigMushroom();
    private final WorldGenBoulders boulderGen = new WorldGenBoulders(Arrays.asList(Blocks.air, Blocks.stone, Blocks.cobblestone), Blocks.cobblestone);

    public ChunkProviderUnderWorld(World world, long seed) {
        this.world = world;
        this.seed = seed;

        Random rng = new Random(seed);

        floor = new ScaledNoise(new OctavesSampler(rng, 4), 0.0075d, 0.0075d, 0.0075d);
        ceiling = new ScaledNoise(new OctavesSampler(rng, 4), 0.0075d, 0.0075d, 0.0075d);
        feature = new SimplexNoiseSampler(rng);

        difficulty = new ScaledNoise(new SimplexNoiseSampler(rng), 0.02, 0.02, 0.02, 2, 2);

        mushrooms = new ScaledNoise(new OctavesSampler(rng, 2), 0.1, 0.1, 0.1, 2, -1.4);
        boulders = new ScaledNoise(new OctavesSampler(rng, 2), 0.1, 0.1, 0.1, 0.1, 0.1);
    }

    @Override
    public Chunk provideChunk(int chunkX, int chunkZ) {
        Chunk chunk = new Chunk(world, chunkX, chunkZ);
        chunk.isModified = true;

        ChunkBlockView view = new ChunkBlockView(chunk);

        view.subViewMutable(Box.horizontalChunkSlice(0, 0))
            .fill(new BlockMeta(Blocks.bedrock, 0));
        view.subViewMutable(new Box(0, 1, 0, 15, 255, 15))
            .fill(new BlockMeta(Blocks.stone, 0));

        int blockX = chunkX * 16;
        int blockZ = chunkZ * 16;

        ImmutableBlockMeta stone = new BlockMeta(Blocks.stone, 0);
        ImmutableBlockMeta cobble = new BlockMeta(Blocks.cobblestone, 0);
        ImmutableBlockMeta air = new BlockMeta(Blocks.air, 0);

        // Each chunk is generated by column.
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                int x2 = blockX + x;
                int z2 = blockZ + z;

                int floorLevel = getFloorLevel(x2, z2);
                int ceilingLevel = getCeilingLevel(x2, z2);

                // Generate the basic terrain
                for (int y = floorLevel - 2; y < ceilingLevel + 3; y++) {
                    ImmutableBlockMeta bm = air;

                    if (y <= floorLevel || y >= ceilingLevel) {
                        bm = cobble;
                    }

                    view.setBlock(x, y, z, bm);
                }

                // Get the raw feature noise. This controls pillars and holes.
                // The domain is [-1, 1]
                double feature = this.feature.sample(x2 * 0.025, z2 * 0.025);

                // We only want to generate pillars at noise values 0.75 and up.
                // This value controls how much of the pillar is 'full' for this column.
                // In other words, 0.5 means the stone goes 25% up from the bottom and 25% down from the top.
                double pillar = linearCurve(feature, 0.75, 0, 0.9, 1);

                boolean hasPillar = pillar > 0;

                // Generate pillar, if present
                if (hasPillar) {
                    double span = 1d / (ceilingLevel - floorLevel);

                    double bump = this.feature.sample(x2, z2) * 0.1 - 0.05;

                    // Replace the cobble shell from the terraingen with stone
                    for (int y = floorLevel - 3; y <= floorLevel; y++) {
                        view.setBlock(x, y, z, stone);
                    }

                    for (int y = ceilingLevel; y <= ceilingLevel + 3; y++) {
                        view.setBlock(x, y, z, stone);
                    }

                    // Generate the pillar stone
                    for (int y = floorLevel + 1; y < ceilingLevel; y++) {
                        int dist = Math.min(y - floorLevel - 1, ceilingLevel - y);

                        // This is magic... I don't know how it works and I didn't know how it worked when I made it
                        double scalar = MathHelper.sin((float) (span * (double) dist * 2 + bump));

                        if (scalar < pillar) {
                            view.setBlock(x, y, z, stone);
                        }
                    }

                    // Set the inner-most 2 stone blocks to cobble stone (bottom half)
                    for (int y = floorLevel + 1; y < ceilingLevel; y++) {
                        if (view.getBlock(x, y, z) != Blocks.stone) {
                            for (int y2 = y - 1; y2 > Math.max(floorLevel, y - 3); y2--) {
                                view.setBlock(x, y2, z, cobble);
                            }
                            break;
                        }
                    }

                    // Set the inner-most 2 stone blocks to cobble stone (top half)
                    for (int y = ceilingLevel - 1; y > floorLevel; y--) {
                        if (view.getBlock(x, y, z) != Blocks.stone) {
                            for (int y2 = y + 1; y2 < Math.min(ceilingLevel, y + 3); y2++) {
                                view.setBlock(x, y2, z, cobble);
                            }
                            break;
                        }
                    }
                }

                // Generate void holes
                if (feature <= -0.7) {
                    // Use an aggressive curve here to make the walls extremely steep, while maintaining an obvious slope.
                    double holeDepth = linearCurve(feature, -0.75, 1, -0.7, 0);

                    int holeLevel = (int) (floorLevel * (1 - holeDepth));

                    for (int y = floorLevel; y >= holeLevel; y--) {
                        view.setBlock(x, y, z, air);
                    }
                }
            }
        }

        // Populate the biomes from the world chunk manager
        BiomeGenBase[] biomes = world.getWorldChunkManager()
            .loadBlockGeneratorData(null, chunkX * 16, chunkZ * 16, 16, 16);

        byte[] biomeIDs = chunk.getBiomeArray();

        for (int k = 0; k < biomeIDs.length; ++k) {
            biomeIDs[k] = (byte) biomes[k].biomeID;
        }

        // Fix the height maps
        chunk.generateSkylightMap();
        chunk.resetRelightChecks();

        // Scan the chunk for mineshaft starts
        mineshaftGenerator.func_151539_a(this, world, chunkX, chunkZ, null);

        return chunk;
    }

    /// Gets the ceiling block level for the given column (returned value is the lowest non-air terrain block)
    private int getCeilingLevel(int x, int z) {
        return CEILING.lerp(this.ceiling.sample(x, z));
    }

    /// Gets the floor block level for the given column (returned value is the highest non-air terrain block)
    private int getFloorLevel(int x, int z) {
        return FLOOR.lerp(this.floor.sample(x, z));
    }

    public static double map(double x, double in_min, double in_max, double out_min, double out_max) {
        return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    }

    public static double clamp(double val, double lo, double hi) {
        return Math.min(hi, Math.max(val, lo));
    }

    public static double linearCurve(double x, double x1, double y1, double x2, double y2) {
        x = clamp(x, Math.min(x1, x2), Math.max(x1, x2));

        return map(x, x1, x2, y1, y2);
    }

    /// Populates the given chunk. Note that MC populates the +X/+Z corner of it, not the chunk itself.
    /// All positions should be offset by +8,+8 to account for this.
    /// The 4 chunks around the corner are properly generated and may be accessed. Modifying chunks outside of these 4 will cause cascading worldgen.
    @Override
    public void populate(IChunkProvider provider, int chunkX, int chunkZ) {
        // Initialize the RNG with a deterministic seed
        long seed = Fnv1a64.initialState();
        seed = Fnv1a64.hashStep(seed, this.seed);
        seed = Fnv1a64.hashStep(seed, chunkX);
        seed = Fnv1a64.hashStep(seed, chunkZ);
        rng.setSeed(seed);

        int blockX = chunkX * 16;
        int blockZ = chunkZ * 16;

        MinecraftForge.EVENT_BUS.post(new Pre(provider, world, rng, chunkX, chunkZ, false));

        // Generate water lakes, if possible
        if (this.rng.nextInt(32) == 0 && TerrainGen.populate(provider, world, rng, chunkX, chunkZ, false, LAKE)) {
            int x = blockX + this.rng.nextInt(16) + 8;
            int z = blockZ + this.rng.nextInt(16) + 8;

            if (isValidFeatureSpot(x, z)) {
                WATER_LAKES.generate(this.world, this.rng, x, getFloorLevel(x, z), z);
            }
        }

        // Generate lava lakes, if possible. More common than water lakes.
        if (this.rng.nextInt(16) == 0 && TerrainGen.populate(provider, world, rng, chunkX, chunkZ, false, LAVA)) {
            int x = blockX + this.rng.nextInt(16) + 8;
            int z = blockZ + this.rng.nextInt(16) + 8;

            if (isValidFeatureSpot(x, z)) {
                LAVA_LAKES.generate(this.world, this.rng, x, getFloorLevel(x, z), z);
            }
        }

        // Do biome decoration (ore gen, mostly)
        BiomeGenBase biome = this.world.getBiomeGenForCoords(blockX + 16, blockZ + 16);
        biome.decorate(this.world, this.rng, blockX, blockZ);

        // Build any mineshafts
        mineshaftGenerator.generateStructuresInChunk(world, rng, chunkX, chunkZ);

        // Try to place a boulder in this chunk, if needed
        if (rng.nextDouble() <= getBoulder(chunkX, chunkZ)) {
            for (int tries = 0; tries < 4; tries++) {
                int x = blockX + this.rng.nextInt(16) + 8;
                int z = blockZ + this.rng.nextInt(16) + 8;

                int y = getFloorLevel(x, z) + 1;

                if (isValidFeatureSpot(x, z)) {
                    if (boulderGen.generate(world, rng, x, y, z)) break;
                }
            }
        }

        int mushrooms = getMushroom(chunkX, chunkZ);

        // Try to place mushrooms in this chunk
        for (int placed = 0, tries = 0; placed <= mushrooms && tries < 10; tries++) {
            int x = blockX + this.rng.nextInt(16) + 8;
            int z = blockZ + this.rng.nextInt(16) + 8;

            if (!isValidFeatureSpot(x, z)) {
                continue;
            }

            int y = getFloorLevel(x, z) + 1;

            // If the terrain was excavated by a lake/etc, don't spawn a mushroom here
            if (!validMyceliumSpawnLocation(x, y - 1, z)) {
                continue;
            }

            // bigMushroomGen needs something that mushrooms can spawn on to work, place some temporary mycelium
            world.setBlock(x, y - 1, z, Blocks.mycelium);

            // Fallibly place the mushroom
            if (!this.bigMushroomGen.generate(this.world, this.rng, x, y, z)) {
                // If it failed, revert the cobble to mycelium
                world.setBlock(x, y - 1, z, Blocks.cobblestone);
                continue;
            }

            // Generate some extra mycelium around the base to make it look like a growth on the floor
            spawnMycelium(x, y - 1, z, 13);
            placed++;
        }

        // Spawn some monsters
        if (TerrainGen.populate(provider, world, rng, chunkX, chunkZ, false, ANIMALS)) {
            SpawnerAnimals.performWorldGenSpawning(this.world, biome, blockX + 8, blockZ + 8, 16, 16, this.rng);
        }

        MinecraftForge.EVENT_BUS.post(new Post(provider, world, rng, chunkX, chunkZ, false));
    }

    /// Checks if the column is far enough from pillars and holes for populated features to spawn
    private boolean isValidFeatureSpot(int x, int z) {
        double feature = this.feature.sample(x * 0.025, z * 0.025);
        return feature >= -0.5 && feature <= 0.5;
    }

    /// Checks what ceatures can spawn on the given block
    @Override
    public List<SpawnListEntry> getPossibleCreatures(EnumCreatureType creatureType, int x, int y, int z) {
        BiomeGenBase biome = this.world.getBiomeGenForCoords(x, z);
        return biome.getSpawnableList(creatureType);
    }

    /// Scans the chunk for existing structures
    @Override
    public void recreateStructures(int chunkX, int chunkZ) {
        mineshaftGenerator.func_151539_a(this, world, chunkX, chunkZ, null);
    }

    /// Gets the difficulty for this chunk. Domain: [0, 4]. Represents the multiplier for material gains and mob spawns.
    /// Difficulties above 2 have aggressive mob spawning.
    public double getDifficulty(int chunkX, int chunkZ) {
        if (!UnderWorldConfig.enableDifficulty) return 0;

        return difficulty.sample(chunkX, chunkZ);
    }

    /// Gets the chance for big mushrooms in the given chunk. Domain: [0, 2]
    private int getMushroom(int chunkX, int chunkZ) {
        return (int) Math.min(2, mushrooms.sample(chunkX, chunkZ));
    }

    /// Gets the chance for boulders in the given chunk. Domain: [0, 1]
    private double getBoulder(int chunkX, int chunkZ) {
        return boulders.sample(chunkX, chunkZ);
    }

    private static final ForgeDirection[] HORIZONTAL = {
        ForgeDirection.NORTH,
        ForgeDirection.SOUTH,
        ForgeDirection.WEST,
        ForgeDirection.EAST,
    };

    /// Checks to make sure the location is a valid mycelium spot. Has a special case for the initial block (mushroom block on top of mycelium)
    private boolean validMyceliumSpawnLocation(int x, int y, int z) {
        Block block = world.getBlock(x, y, z);
        Block above = world.getBlock(x, y + 1, z);

        return (block == Blocks.cobblestone || block == Blocks.mycelium) && (above.isAir(world, x, y + 1, z) || above == Blocks.brown_mushroom_block || above == Blocks.red_mushroom_block);
    }

    /// Spawns mycelium blocks in place of cobble stone randomly, starting from the given coordinate.
    private void spawnMycelium(int x, int y, int z, int amount) {
        LongArrayFIFOQueue queue = new LongArrayFIFOQueue();

        queue.enqueue(CoordinatePacker.pack(x, y, z));

        while (!queue.isEmpty() && amount > 0) {
            long curr = queue.dequeueLong();

            int x2 = CoordinatePacker.unpackX(curr);
            int y2 = CoordinatePacker.unpackY(curr);
            int z2 = CoordinatePacker.unpackZ(curr);

            boolean valid = validMyceliumSpawnLocation(x2, y2, z2);

            if (!valid && validMyceliumSpawnLocation(x2, y2 + 1, z2)) {
                y2++;
                valid = true;
            }

            if (!valid && validMyceliumSpawnLocation(x2, y2 - 1, z2)) {
                y2--;
                valid = true;
            }

            if (!valid) continue;

            world.setBlock(x2, y2, z2, Blocks.mycelium);
            amount--;

            int i = rng.nextInt(4);

            ForgeDirection dir = HORIZONTAL[i];
            queue.enqueue(CoordinatePacker.pack(x2 + dir.offsetX, y2 + dir.offsetY, z2 + dir.offsetZ));

            i += rng.nextInt(4);

            dir = HORIZONTAL[i % 4];
            queue.enqueue(CoordinatePacker.pack(x2 + dir.offsetX, y2 + dir.offsetY, z2 + dir.offsetZ));

            i += rng.nextInt(4);

            dir = HORIZONTAL[i % 4];
            queue.enqueue(CoordinatePacker.pack(x2 + dir.offsetX, y2 + dir.offsetY, z2 + dir.offsetZ));
        }
    }

    // <editor-fold desc="Stubs" defaultstate="collapsed">

    @Override
    public Chunk loadChunk(int x, int z) {
        return provideChunk(x, z);
    }

    @Override
    public String makeString() {
        return "UnderWorld";
    }

    @Override
    public boolean chunkExists(int x, int z) {
        return true;
    }

    @Override
    public boolean saveChunks(boolean p_73151_1_, IProgressUpdate p_73151_2_) {
        return false;
    }

    @Override
    public boolean unloadQueuedChunks() {
        return false;
    }

    @Override
    public boolean canSave() {
        return false;
    }

    @Override
    public ChunkPosition func_147416_a(World world, String structureName, int x, int y, int z) {
        // findClosestStructure(String type, int x, int y, int z)
        return null;
    }

    @Override
    public int getLoadedChunkCount() {
        return 0;
    }

    @Override
    public void saveExtraData() {

    }

    // </editor-fold>
}
